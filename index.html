<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>精准2FA验证码生成器（终极版）</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            max-width: 900px; 
            margin: 30px auto; 
            padding: 20px; 
            text-align: center;
        }
        h1 { color: #333; margin: 20px 0; font-size: 2.2em; }
        .secret-input {
            width: 100%;
            padding: 15px;
            font-size: 1.5em;
            border: 2px solid #eee;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
            resize: none;
            min-height: 100px;
        }
        .secret-input:focus {
            border-color: #5865F2;
            outline: none;
            box-shadow: 0 0 8px rgba(88, 101, 242, 0.2);
        }
        .code-container {
            margin: 30px 0;
        }
        .main-code {
            font-size: 6em;
            font-weight: bold;
            color: #5865F2;
            letter-spacing: 8px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 15px;
            cursor: pointer;
        }
        .main-code.copied {
            color: #27ae60;
            background: #eafaf1;
        }
        .extra-codes {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .extra-code {
            font-size: 2em;
            color: #666;
            padding: 10px 20px;
            background: #f0f0f0;
            border-radius: 8px;
        }
        .countdown {
            font-size: 1.8em;
            color: #666;
            margin: 10px 0;
        }
        .btn-group {
            margin: 20px 0;
        }
        button {
            padding: 12px 25px;
            margin: 0 10px;
            font-size: 1.2em;
            border: none;
            border-radius: 8px;
            background: #5865F2;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover {
            background: #4752C4;
        }
        .tip {
            color: #999;
            font-size: 1.1em;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>精准2FA验证码生成器</h1>
    
    <textarea class="secret-input" id="secretInput" placeholder="粘贴目标平台的2FA密钥（请勿手动输入）">FXVLGSEADALXX6BBY3NT3FUU2BUVV7QA</textarea>
    
    <div class="btn-group">
        <button onclick="updateAllCodes()">刷新所有验证码</button>
        <button onclick="resetSecret()">重置密钥</button>
    </div>

    <div class="code-container">
        <div class="main-code" id="mainCode" onclick="copyCode()">点击复制验证码</div>
        <div class="extra-codes">
            <div class="extra-code">上30秒: <span id="prevCode">----</span></div>
            <div class="extra-code">下30秒: <span id="nextCode">----</span></div>
        </div>
    </div>

    <div class="countdown" id="countdown">剩余有效时间：--秒</div>
    <div class="tip">提示：若主验证码不匹配，尝试用上/下30秒的验证码测试</div>

    <script>
        // 核心配置
        const INTERVAL = 30;
        let currentSecret = document.getElementById('secretInput').value.trim();

        // 标准Base32解码（严格兼容RFC4648）
        function base32Decode(secret) {
            const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            secret = secret.toUpperCase().replace(/[^A-Z2-7]/g, '');
            if (secret.length === 0) return new Uint8Array(0);

            let bits = '';
            for (let c of secret) {
                const idx = ALPHABET.indexOf(c);
                if (idx === -1) continue;
                bits += idx.toString(2).padStart(5, '0');
            }

            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                const byte = bits.slice(i, i + 8);
                if (byte.length === 8) bytes.push(parseInt(byte, 2));
            }
            return new Uint8Array(bytes);
        }

        // 标准HMAC-SHA1实现（无环境依赖）
        function hmacSHA1(keyBytes, dataBytes) {
            function sha1(arr) {
                const K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
                const H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
                
                arr = new Uint8Array([...arr, 0x80]);
                while (arr.length % 64 !== 56) arr = new Uint8Array([...arr, 0]);
                const len = (originalLength * 8).toString(16).padStart(16, '0');
                const lenBytes = new Uint8Array(8);
                for (let i = 0; i < 8; i++) lenBytes[i] = parseInt(len.substr(i*2, 2), 16);
                arr = new Uint8Array([...arr, ...lenBytes]);

                for (let i = 0; i < arr.length; i += 64) {
                    const block = arr.slice(i, i + 64);
                    const W = new Array(80);
                    for (let j = 0; j < 16; j++) W[j] = (block[j*4]<<24)|(block[j*4+1]<<16)|(block[j*4+2]<<8)|block[j*4+3];
                    for (let j = 16; j < 80; j++) W[j] = W[j-3]^W[j-8]^W[j-14]^W[j-16];
                    
                    let [a, b, c, d, e] = H;
                    for (let j = 0; j < 80; j++) {
                        let f, k;
                        if (j < 20) { f = (b&c)|(~b&d); k = K[0]; }
                        else if (j < 40) { f = b^c^d; k = K[1]; }
                        else if (j < 60) { f = (b&c)|(b&d)|(c&d); k = K[2]; }
                        else { f = b^c^d; k = K[3]; }
                        const temp = (a<<5|a>>>27) + f + e + k + W[j] & 0xFFFFFFFF;
                        e = d; d = c; c = b<<30|b>>>2; b = a; a = temp;
                    }
                    H[0] = H[0] + a & 0xFFFFFFFF;
                    H[1] = H[1] + b & 0xFFFFFFFF;
                    H[2] = H[2] + c & 0xFFFFFFFF;
                    H[3] = H[3] + d & 0xFFFFFFFF;
                    H[4] = H[4] + e & 0xFFFFFFFF;
                }

                const result = [];
                for (let h of H) {
                    result.push(h>>24 & 0xFF);
                    result.push(h>>16 & 0xFF);
                    result.push(h>>8 & 0xFF);
                    result.push(h & 0xFF);
                }
                return new Uint8Array(result);
            }

            let originalLength = dataBytes.length;
            if (keyBytes.length > 64) keyBytes = sha1(keyBytes);
            if (keyBytes.length < 64) keyBytes = new Uint8Array([...keyBytes, ...new Uint8Array(64 - keyBytes.length)]);
            
            const ipad = new Uint8Array(64);
            const opad = new Uint8Array(64);
            for (let i = 0; i < 64; i++) {
                ipad[i] = keyBytes[i] ^ 0x36;
                opad[i] = keyBytes[i] ^ 0x5C;
            }

            const inner = sha1(new Uint8Array([...ipad, ...dataBytes]));
            return sha1(new Uint8Array([...opad, ...inner]));
        }

        // 生成指定时间偏移的验证码
        function generateCode(offset = 0) {
            if (!currentSecret) return '无密钥';
            const secretBytes = base32Decode(currentSecret);
            if (secretBytes.length === 0) return '密钥错误';

            const time = Math.floor(Date.now() / 1000 / INTERVAL) + offset;
            const timeBuffer = new ArrayBuffer(8);
            new DataView(timeBuffer).setBigInt64(0, BigInt(time), false);
            const timeBytes = new Uint8Array(timeBuffer);

            const hmac = hmacSHA1(secretBytes, timeBytes);
            const offsetIdx = hmac[hmac.length - 1] & 0x0F;
            const code = (
                ((hmac[offsetIdx] & 0x7F) << 24) |
                ((hmac[offsetIdx + 1] & 0xFF) << 16) |
                ((hmac[offsetIdx + 2] & 0xFF) << 8) |
                (hmac[offsetIdx + 3] & 0xFF)
            ) % 1000000;

            return code.toString().padStart(6, '0');
        }

        // 更新所有验证码和倒计时
        function updateAllCodes() {
            currentSecret = document.getElementById('secretInput').value.trim();
            
            // 生成当前/上/下30秒的验证码
            document.getElementById('mainCode').textContent = generateCode(0);
            document.getElementById('prevCode').textContent = generateCode(-1);
            document.getElementById('nextCode').textContent = generateCode(1);
            
            // 更新倒计时
            const remaining = INTERVAL - (Math.floor(Date.now() / 1000) % INTERVAL);
            document.getElementById('countdown').textContent = `剩余有效时间：${remaining}秒`;
        }

        // 复制验证码
        function copyCode() {
            const code = document.getElementById('mainCode').textContent;
            if (code.length !== 6) return;
            
            navigator.clipboard.writeText(code).then(() => {
                const el = document.getElementById('mainCode');
                el.classList.add('copied');
                el.textContent = '✅ ' + code;
                setTimeout(() => {
                    el.classList.remove('copied');
                    el.textContent = code;
                }, 1500);
            });
        }

        // 重置密钥
        function resetSecret() {
            currentSecret = 'FXVLGSEADALXX6BBY3NT3FUU2BUVV7QA';
            document.getElementById('secretInput').value = currentSecret;
            updateAllCodes();
        }

        // 初始化+自动刷新
        window.onload = () => {
            updateAllCodes();
            setInterval(updateAllCodes, 1000);
            
            // 回车刷新
            document.getElementById('secretInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    updateAllCodes();
                }
            });
        };
    </script>
</body>
</html>
