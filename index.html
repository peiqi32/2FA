<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2FA验证码生成器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .input-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }
        .result {
            margin-top: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            text-align: center;
        }
        .result h3 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .code {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            letter-spacing: 2px;
        }
        .tip {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>2FA验证码生成器</h1>
        
        <div class="input-group">
            <label for="secret">密钥(Secret)</label>
            <input type="text" id="secret" placeholder="请输入2FA密钥" value="">
        </div>
        
        <div class="result">
            <h3>当前验证码</h3>
            <div class="code" id="code">----</div>
            <div class="tip" id="tip">验证码每30秒刷新一次</div>
        </div>
    </div>

    <script>
        // 解析URL路径中的密钥
        function getSecretFromPath() {
            const path = window.location.pathname;
            // 去掉开头的"/"，并过滤空字符（防止路径为"/"的情况）
            const secret = path.slice(1).trim();
            return secret || '';
        }

        // 生成TOTP验证码（基于RFC 6238标准）
        function generateTOTP(secret) {
            if (!secret) return '';
            
            // 将Base32密钥转换为字节数组
            function base32ToBytes(base32) {
                const base32Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
                base32 = base32.replace(/=/g, '').toUpperCase();
                let bits = '';
                let bytes = [];

                for (let i = 0; i < base32.length; i++) {
                    const val = base32Alphabet.indexOf(base32[i]);
                    if (val === -1) throw new Error('无效的Base32字符');
                    bits += val.toString(2).padStart(5, '0');
                }

                for (let i = 0; i < bits.length; i += 8) {
                    const byte = bits.slice(i, i + 8);
                    if (byte.length === 8) {
                        bytes.push(parseInt(byte, 2));
                    }
                }
                return new Uint8Array(bytes);
            }

            // 获取当前时间戳（30秒步长）
            const time = Math.floor(Date.now() / 1000 / 30);
            const timeBytes = new ArrayBuffer(8);
            const timeView = new DataView(timeBytes);
            timeView.setUint32(4, time, false); // 大端序存储

            // 使用HMAC-SHA1计算
            return crypto.subtle.importKey(
                'raw',
                base32ToBytes(secret),
                { name: 'HMAC', hash: 'SHA-1' },
                false,
                ['sign']
            ).then(key => {
                return crypto.subtle.sign('HMAC', key, timeBytes);
            }).then(signature => {
                // 截取最后4位作为偏移量
                const offset = new Uint8Array(signature)[signature.byteLength - 1] & 0xf;
                const codeView = new DataView(signature.slice(offset, offset + 4));
                const code = (codeView.getUint32(0, false) & 0x7fffffff) % 1000000;
                return code.toString().padStart(6, '0');
            }).catch(err => {
                console.error('生成验证码失败:', err);
                return '';
            });
        }

        // 自动复制到剪贴板
        function copyToClipboard(text) {
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                document.getElementById('tip').textContent = '验证码已自动复制到剪贴板！';
            }).catch(err => {
                console.error('复制失败:', err);
                document.getElementById('tip').textContent = '复制失败，请手动复制';
            });
        }

        // 更新验证码并自动复制
        async function updateCode() {
            const secret = document.getElementById('secret').value.trim();
            const code = await generateTOTP(secret);
            
            if (code) {
                document.getElementById('code').textContent = code;
                copyToClipboard(code); // 自动复制
            } else {
                document.getElementById('code').textContent = '----';
                document.getElementById('tip').textContent = '请输入有效的密钥';
            }
        }

        // 初始化页面
        function init() {
            // 从URL路径读取密钥并填充
            const secretFromPath = getSecretFromPath();
            if (secretFromPath) {
                document.getElementById('secret').value = secretFromPath;
            }

            // 首次生成验证码
            updateCode();

            // 每30秒刷新一次
            setInterval(updateCode, 30000);

            // 监听输入框变化
            document.getElementById('secret').addEventListener('input', updateCode);
        }

        // 启动初始化
        init();
    </script>
</body>
</html>
